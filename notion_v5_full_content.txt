=== ë…¸ì…˜ í¬íŠ¸í´ë¦¬ì˜¤ v5 - Final ì „ì²´ ë‚´ìš© ===

# ğŸ‘¤ ì¡°ë½í˜„ (Rakhyeun Jo)
âš¡ Senior Embedded Engineer | 9ë…„ì°¨ | HW/FW Full-Stack ê°œë°œì
## ğŸ“‹ í•µì‹¬ ì—­ëŸ‰
- ì„ë² ë””ë“œ ì‹œìŠ¤í…œ: STM32 (F1, F4, H7), ARM Cortex-M ê¸°ë°˜ íŒì›¨ì–´ ê°œë°œ
- í•˜ë“œì›¨ì–´ ì„¤ê³„: PADs, OrCAD ê¸°ë°˜ íšŒë¡œ ì„¤ê³„ ë° PCB Layout
- ì‹¤ì‹œê°„ ì œì–´: FreeRTOS, PID ì œì–´, ëª¨í„° ì œì–´ (Stepper, BLDC)
- ê´‘í•™ ì‹œìŠ¤í…œ: UV/IR LED, Photo Diode Array, ë ˆì´ì € ê´‘í•™ê³„
- í†µì‹  í”„ë¡œí† ì½œ: UART, SPI, I2C, Ethernet (LwIP), TCP/UDP
---

================================================================================
[í† ê¸€] ğŸ’§ Nu-2000 (Lux) - UV+IR ìš©ì•¡ ë†ë„ ë¶„ì„ê¸°
================================================================================
  ğŸ”¬ UV+IR ê´‘í•™ì„ ì´ìš©í•œ ìš©ì•¡ ë†ë„ ë¶„ì„ ì¥ë¹„
  ### í”„ë¡œì íŠ¸ ê°œìš”
  - ì œí’ˆ: UV+IR(ê´‘í•™)ë¥¼ ì´ìš©í•œ ìš©ì•¡ ë†ë„ ë¶„ì„ ì¥ë¹„
  - ì—­í• : íšŒë¡œ ì„¤ê³„ + íŒì›¨ì–´ ê°œë°œ (100%)
  - MCU: STM32F407 (ARM Cortex-M4, 168MHz)
  ### ì‹œìŠ¤í…œ ë¸”ë¡ ë‹¤ì´ì–´ê·¸ë¨
  ğŸ’¡ 
  ğŸ’¡ 
  ### í•µì‹¬ ê¸°ìˆ 
  - UV/IR LED ê´‘í•™ ì¸¡ì •: í¡ê´‘ë„ ê¸°ë°˜ ë†ë„ ë¶„ì„
  - ADS1115 16ë¹„íŠ¸ ADC: I2C ì¸í„°í˜ì´ìŠ¤, Delta-Sigma ë°©ì‹
  - ì´ë™í‰ê·  í•„í„°: ë…¸ì´ì¦ˆ ì œê±° ë° ì¸¡ì • ì•ˆì •í™”
  - Nextion HMI LCD: í„°ì¹˜ìŠ¤í¬ë¦° UI
  ### ì½”ë“œ ìƒ˜í”Œ - I2C ì„¼ì„œ ë°ì´í„° ì´ë™í‰ê· 
  ```c
// ADS1115.c - I2C ADC ì„¼ì„œ ë°ì´í„° ìˆ˜ì§‘ ë° ì´ë™í‰ê·  ê³„ì‚°
// UV/IR Photo Diode ì‹ í˜¸ë¥¼ 16ë¹„íŠ¸ ADCë¡œ ì¸¡ì •

/* I2Cë¥¼ í†µí•œ ADC ë°ì´í„° ì½ê¸° */
int ads1115_read(uint16_t addr, uint8_t *pdata) {
    uint16_t i2c_addr = (addr | 0x01);  // Read operation
    int result = HAL_I2C_Master_Receive(&hi2c3, i2c_addr, pdata, 2, 10);
    ads1115_i2c_err_check(addr, result);
    return result;
}

/* ì´ë™í‰ê·  ê³„ì‚° - ë…¸ì´ì¦ˆ ì œê±° ë° ì•ˆì •ì  ì¸¡ì • */
void adc_pd_svc_beta(uint8_t ch, int sig_dark, uint16_t val) {
    uint32_t sum;
    int i, cnt;
    
    // ë²„í¼ í¬ì¸í„° ì¦ê°€ (ìˆœí™˜ ë²„í¼)
    cnt = pPD_STR->ma_cnt;
    if (++cnt >= ((bd.env.working[FILTER] & 0x00FFFFFF) * 5))
        cnt = 0;
    pPD_STR->ma_cnt = cnt;
    
    // ADC ê°’ ì €ì¥ (ì–‘ìˆ˜ë§Œ í—ˆìš©)
    pPD_STR->raw[cnt] = val;
    if (val < 0x8000) {
        pPD_STR->raw_pos[cnt] = val;
        pPD_STR->vtg_raw = (float)val * 0.000125;  // 125uV/step
    } else {
        pPD_STR->raw_pos[cnt] = 0;
    }
    
    // ì´ë™í‰ê·  ê³„ì‚° (Filter * 5íšŒ ìƒ˜í”Œ)
    sum = 0;
    for (i = 0; i < ((bd.env.working[FILTER] & 0x00FFFFFF) * 5); i++) 
        sum += pPD_STR->raw_pos[i];
    
    pPD_STR->raw_mavg = (uint16_t)((float)sum / (float)((bd.env.working[FILTER] & 0x00FFFFFF) * 5));
    pPD_STR->vtg_mavg = (float)pPD_STR->raw_mavg * 0.000125;  // ì „ì•• ë³€í™˜
}
  ```
  ---


================================================================================
[í† ê¸€] ğŸ§ª L-Titrator - ì ì •ì‹ ìš©ì•¡ ë†ë„ ë¶„ì„ê¸°
================================================================================
  âš—ï¸ ì ì •(Titration) ë°©ì‹ì„ í™œìš©í•œ ìš©ì•¡ ë†ë„ ë¶„ì„ ì¥ë¹„
  ### í”„ë¡œì íŠ¸ ê°œìš”
  - ì œí’ˆ: ì ì • ë°©ì‹ì„ í™œìš©í•œ ìš©ì•¡ ë†ë„ ë¶„ì„ ì¥ë¹„
  - ì—­í• : íšŒë¡œ ì„¤ê³„ + íŒì›¨ì–´ ê°œë°œ (100%)
  - MCU: STM32F407 (ARM Cortex-M4)
  ### ì‹œìŠ¤í…œ ë¸”ë¡ ë‹¤ì´ì–´ê·¸ë¨
  ğŸ’¡ 
  ### í•µì‹¬ ê¸°ìˆ 
  - Hamilton ì‹œë¦°ì§€ íŒí”„: RS485 í”„ë¡œí† ì½œ ì œì–´
  - ìƒíƒœë¨¸ì‹  ê¸°ë°˜ ì œì–´: ì•ˆì •ì ì¸ íŒí”„ ë™ì‘ ê´€ë¦¬
  - pH/ì „ë„ë„ ì„¼ì„œ: ì ì • ì¢…ë§ì  ìë™ ê²€ì¶œ
  ### ì½”ë“œ ìƒ˜í”Œ - ì‹œë¦°ì§€ íŒí”„ ìƒíƒœë¨¸ì‹ 
  ```c
// syringe_pump_ctrl.c - Hamilton ì‹œë¦°ì§€ íŒí”„ ìƒíƒœë¨¸ì‹  ì œì–´
// RS485 í†µì‹ ìœ¼ë¡œ ì‹œë¦°ì§€ íŒí”„ ëª…ë ¹/ì‘ë‹µ ì²˜ë¦¬

/* ì‹œë¦°ì§€ íŒí”„ ìƒíƒœ ë¨¸ì‹  */
void syr_pump_st10_svc(void) {
    int data_pos;
    
    switch (syr_pump[syr_pump_ch].st) {
        case 0x10:  // ì‹œë¦°ì§€ ìƒíƒœ ì¡°íšŒ
            syr_pump_query_cmd(QUERY_SRG_STATUS);
            syr_pump[syr_pump_ch].st++;
            syr_pump[syr_pump_ch].resp_cnt = 0;
            break;
            
        case 0x11:  // ì‘ë‹µ ëŒ€ê¸° ë° ì²˜ë¦¬
            if (++syr_pump[syr_pump_ch].resp_cnt >= SRG_PUMP_RESP_TIMEOUT) {
                // íƒ€ì„ì•„ì›ƒ - ì´ˆê¸° ìƒíƒœë¡œ ë³µê·€
                syr_pump[syr_pump_ch].st = SRG_PUMP_ST00_DETECT;
                trace_printf(TPID_DEBUG, "syr_pump[%d] : no response\n", syr_pump_ch);
            } else {
                if (syr_pump_rx_flag == 1) {
                    syr_pump_rx_flag = 0;
                    data_pos = is_Q_ack_packet(uart[TPID_RS485].command, uart[TPID_RS485].cmd_index);
                    
                    if (data_pos > 0) {
                        syr_pump[syr_pump_ch].syr_status = syr_pump[syr_pump_ch].temp;
                        if (syr_pump[syr_pump_ch].syr_status == 0) {
                            trace_printf(TPID_DEBUG, "syr_pump[%d] : initialized\n", syr_pump_ch);
                            syr_pump[syr_pump_ch].st++;
                        }
                    }
                }
            }
            break;
    }
}
  ```
  ---


================================================================================
[í† ê¸€] ğŸ”¬ Psi-1000/3000 - ì •ë°€ ê°€ìŠ¤ ì œì–´ ì‹œìŠ¤í…œ
================================================================================
  ğŸ¯ ì§„ê³µ ê²Œì´ì§€ ëª¨ë‹ˆí„°ë§ ê¸°ë°˜ ì •ë°€ ê°€ìŠ¤ ì œì–´ ì‹œìŠ¤í…œ
  ### í”„ë¡œì íŠ¸ ê°œìš”
  - ì œí’ˆ: ì •ë°€ ê°€ìŠ¤ ì œì–´ ì‹œìŠ¤í…œ (ë°˜ë„ì²´/ë””ìŠ¤í”Œë ˆì´ ê³µì •ìš©)
  - ì—­í• : íšŒë¡œ ì„¤ê³„ + íŒì›¨ì–´ ê°œë°œ (100%)
  - MCU: STM32F407 (ARM Cortex-M4, 168MHz)
  ### ì‹œìŠ¤í…œ ë¸”ë¡ ë‹¤ì´ì–´ê·¸ë¨
  ğŸ’¡ 
  ### í•µì‹¬ ê¸°ìˆ 
  - ê³ ì† PID í”¼ë“œë°± ì œì–´: 250ms ì£¼ê¸° ì••ë ¥ ì œì–´
  - FreeRTOS ë©€í‹°íƒœìŠ¤í‚¹: ì••ë ¥ì œì–´, ì„¼ì„œ, í†µì‹  ë³‘ë ¬ ì²˜ë¦¬
  - Ethernet (LwIP): TCP/UDP PC ì œì–´ ì¸í„°í˜ì´ìŠ¤
  - PID Auto-Tuning: ìµœì  íŒŒë¼ë¯¸í„° ìë™ íƒìƒ‰
  ### ì½”ë“œ ìƒ˜í”Œ - ê°€ìŠ¤ ì••ë ¥ PID ì œì–´
  ```c
// PrsCtrl.c - ì •ë°€ ê°€ìŠ¤ ì••ë ¥ PID ì œì–´
// ì§„ê³µ ê²Œì´ì§€ ëª¨ë‹ˆí„°ë§ + 250ms ì£¼ê¸° ê³ ì† í”¼ë“œë°±

/* ì••ë ¥ ì œì–´ ë³€ìˆ˜ */
INTERNAL float32_t sglPrsCtrlFilteredPressureP1;   // ì…ë ¥ ì••ë ¥ (torr)
INTERNAL float32_t sglPrsCtrlControlPeriod = 0.25f; // 250ms ì œì–´ ì£¼ê¸°

/* PID ì••ë ¥ ì œì–´ ì•Œê³ ë¦¬ì¦˜ */
void pid_pressure_compute(PID_STR *pPID) {
    float error = pPID->sp - pPID->pv;  // ëª©í‘œì••ë ¥ - í˜„ì¬ì••ë ¥
    
    // P (ë¹„ë¡€í•­) - ì¦‰ê°ì ì¸ ì˜¤ì°¨ ë°˜ì‘
    pPID->p_term = pPID->kp * error;
    
    // I (ì ë¶„í•­) - ëˆ„ì  ì˜¤ì°¨ ë³´ì •
    pPID->i_term += pPID->ki * error;
    if (pPID->i_term > pPID->i_max) pPID->i_term = pPID->i_max;
    if (pPID->i_term < pPID->i_min) pPID->i_term = pPID->i_min;
    
    // D (ë¯¸ë¶„í•­) - ê¸‰ê²©í•œ ë³€í™” ì–µì œ
    pPID->d_term = pPID->kd * (error - pPID->prev_error);
    pPID->prev_error = error;
    
    // ìµœì¢… ì¶œë ¥ = ë°¸ë¸Œ PWM ë“€í‹°
    pPID->co = pPID->p_term + pPID->i_term + pPID->d_term;
}
  ```
  ---


================================================================================
[í† ê¸€] ğŸ”´ LPC - ë ˆì´ì € íŒŒí‹°í´ ë¶„ì„ê¸°
================================================================================
  ğŸ’¡ ë ˆì´ì €(ê´‘í•™)ë¥¼ ì´ìš©í•œ ìŠ¬ëŸ¬ë¦¬ íŒŒí‹°í´ ë¶„ì„ ì¥ë¹„
  ### í”„ë¡œì íŠ¸ ê°œìš”
  - ì œí’ˆ: ë ˆì´ì € ê´‘í•™ ê¸°ë°˜ ìŠ¬ëŸ¬ë¦¬ íŒŒí‹°í´ ì¹´ìš´í„°
  - ì—­í• : íšŒë¡œ ì„¤ê³„ + íŒì›¨ì–´ ê°œë°œ (100%)
  - MCU: STM32F407 (ARM Cortex-M4)
  ### ì‹œìŠ¤í…œ ë¸”ë¡ ë‹¤ì´ì–´ê·¸ë¨
  ğŸ’¡ 
  ### í•µì‹¬ ê¸°ìˆ 
  - ë ˆì´ì € ê´‘í•™ê³„: ì‚°ë€ê´‘ ê²€ì¶œ ê¸°ë°˜ íŒŒí‹°í´ ê³„ìˆ˜
  - TCP/IP í†µì‹  (LwIP): PC ì›ê²© ì œì–´ ë° ë°ì´í„° ì „ì†¡
  - FreeRTOS: ë©€í‹°íƒœìŠ¤í‚¹ ê¸°ë°˜ ì‹¤ì‹œê°„ ì²˜ë¦¬
  ### ì½”ë“œ ìƒ˜í”Œ - TCP ì„œë²„ í†µì‹ 
  ```c
// ethernet.c - TCP ì„œë²„ í†µì‹  (LwIP netconn API)
// FreeRTOS íƒœìŠ¤í¬ë¡œ TCP í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ê´€ë¦¬

void TcpTask(void *arg) {
    struct netconn *conn, *newconn;
    err_t err, recv_err;
    
    // 1. TCP ì—°ê²° ìƒì„± ë° ë°”ì¸ë”©
    conn = netconn_new(NETCONN_TCP);
    err = netconn_bind(conn, NULL, TELNET_TCP_PORT);  // Port 23
    netconn_listen(conn);
    
    while (1) {
        task_cnt_tcp++;
        osDelay(1);
        
        // 2. í´ë¼ì´ì–¸íŠ¸ ì—°ê²° ìˆ˜ë½ (1ms íƒ€ì„ì•„ì›ƒ)
        conn->recv_timeout = 1;
        err = netconn_accept(conn, &newconn);
        
        if (err == ERR_OK) {
            bd.eth.tcp.connected = 1;
            netconn_getaddr(newconn, &bd.eth.tcp.remote_ip, &bd.eth.tcp.remote_port, 0);
            
            for (;;) {
                // 3. ë°ì´í„° ìˆ˜ì‹  ì²˜ë¦¬
                newconn->recv_timeout = 1;
                recv_err = netconn_recv(newconn, &buf);
                
                if (recv_err == ERR_OK) {
                    netbuf_data(buf, &data, &len);
                    for (i = 0; i < len; i++)
                        debug_command_process(TPID_TCP, ((char *)data)[i]);
                    netbuf_delete(buf);
                } else if (recv_err == ERR_CLSD) {
                    netconn_close(newconn);
                    break;  // ì—°ê²° ì¢…ë£Œ
                }
            }
        }
    }
}
  ```
  ---


================================================================================
[í† ê¸€] ğŸ“Š SSC - Photo Diode Array ìŠ¬ëŸ¬ë¦¬ ë¶„ì„ê¸°
================================================================================
  ğŸ“ˆ Photo Diode Arrayë¥¼ ì‚¬ìš©í•œ ê´‘í•™ì‹ ìŠ¬ëŸ¬ë¦¬ ë¶„ì„ ì¥ë¹„
  ### í”„ë¡œì íŠ¸ ê°œìš”
  - ì œí’ˆ: PDA ê¸°ë°˜ ê´‘í•™ì‹ ìŠ¬ëŸ¬ë¦¬ ë¶„ì„ê¸°
  - ì—­í• : íšŒë¡œ ì„¤ê³„ + íŒì›¨ì–´ ê°œë°œ (100%)
  - MCU: STM32G0 ì‹œë¦¬ì¦ˆ
  ### ì‹œìŠ¤í…œ ë¸”ë¡ ë‹¤ì´ì–´ê·¸ë¨
  ğŸ’¡ 
  ### í•µì‹¬ ê¸°ìˆ 
  - Photo Diode Array: ë‹¤ì±„ë„ ë™ì‹œ ê´‘í•™ ì¸¡ì •
  - ë¶„ê´‘ ë¶„ì„: íŒŒì¥ë³„ í¡ê´‘ë„ ì¸¡ì •
  - RS485 í†µì‹ : ì™¸ë¶€ ì¥ë¹„ ì—°ë™
  ### ì½”ë“œ ìƒ˜í”Œ - UART ì¸í„°ëŸ½íŠ¸ ë° ë°ì´í„° ìˆ˜ì§‘
  ```c
// SSC_main.c - UART ìˆ˜ì‹  ì¸í„°ëŸ½íŠ¸ ë° í ì²˜ë¦¬
// Photo Diode Array ì„¼ì„œ ë°ì´í„° ìˆ˜ì§‘

/* UART ìˆ˜ì‹  ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ */
void my_uart_rx_irq_handler(UART_HandleTypeDef *huart) {
    TERM_PORT   tpid;
    UART_STR*   pUART;
    uint32_t    isrflags = READ_REG(huart->Instance->ISR);
    
    // 1. UART ì†ŒìŠ¤ ì‹ë³„
    if (huart->Instance == USART1) {
        tpid  = TPID_DEBUG;
        pUART = &uart[TPID_DEBUG];
    } else if (huart->Instance == USART2) {
        tpid  = TPID_RS485;
        pUART = &uart[TPID_RS485];
    } else {
        return;
    }
    
    // 2. ìˆ˜ì‹  ë°ì´í„° ë° ì—ëŸ¬ í”Œë˜ê·¸ ì½ê¸°
    pUART->rx_err_flag = (isrflags & (USART_ISR_PE | USART_ISR_FE | USART_ISR_ORE | USART_ISR_NE));
    pUART->rx_data = (uint8_t)(huart->Instance->RDR & 0x00FF);
    
    // 3. ìˆ˜ì‹  íì— ì €ì¥
    rxQ_write(tpid, pUART->rx_data);
    
    // 4. ì—ëŸ¬ ë°œìƒ ì‹œ ì¶œë ¥
    if (pUART->rx_err_flag)
        term_printf(TPID_DEBUG, "UART[%d] Rx Err: 0x%08x\n", tpid, pUART->rx_err_flag);
}

/* íƒ€ì´ë¨¸ ì¸í„°ëŸ½íŠ¸ (1ms/10ms í‹± ìƒì„±) */
void HAL_IncTick(void) {
    uwTick += uwTickFreq;
    tick_1ms++;
    if ((tick_1ms % 10) == 0) tick_10ms++;
}
  ```
  ---


================================================================================
[í† ê¸€] ğŸ§ª MS (Aston) - ì§ˆëŸ‰ë¶„ì„ê¸° DRV Board
================================================================================
  âš™ï¸ ì§ˆëŸ‰ë¶„ì„ê¸° Drive Board - íŒí”„, ì„¼ì„œ ë“± ì¥ë¹„ ì œì–´
  ### í”„ë¡œì íŠ¸ ê°œìš”
  - ì œí’ˆ: ìˆ˜ì§ˆë¶„ì„ìš© ì§ˆëŸ‰ë¶„ì„ê¸° (Mass Spectrometer)
  - ë‹´ë‹¹: DRV Board íšŒë¡œ ì„¤ê³„ + íŒì›¨ì–´ ê°œë°œ
  - MCU: STM32F407 (ARM Cortex-M4)
  ### ì‹œìŠ¤í…œ ë¸”ë¡ ë‹¤ì´ì–´ê·¸ë¨
  ğŸ’¡ 
  ğŸ’¡ 
  ğŸ’¡ 
  ### DRV Board í•µì‹¬ ê¸°ëŠ¥
  - ì™¸ë¶€ í”„ë¡œí† ì½œ í†µì‹ 
  - High voltage ì œì–´: SEM voltage -1500V, Lens voltage Â±250V
  - PID ì œì–´: ì§„ê³µ íŒí”„ ë° íˆí„° ì •ë°€ ì œì–´
  - ë¦´ë ˆì´ ì œì–´: ì™¸ë¶€ ì¥ë¹„ On/Off ì œì–´
  ### ì½”ë“œ ìƒ˜í”Œ - ì™¸ë¶€ ì¥ë¹„ í”„ë¡œí† ì½œ í†µì‹ 
  ```c
// CS_610F_comm.c - Horiba CS-610F í”„ë¡œí† ì½œ êµ¬í˜„
// DRV Boardì—ì„œ ì™¸ë¶€ ì¥ë¹„ì™€ í†µì‹  í”„ë¡œí† ì½œ ì²˜ë¦¬

/* í”„ë¡œí† ì½œ ì‘ë‹µ ìƒì„± - ì¸¡ì • ë°ì´í„° ì „ì†¡ */
// Command : R,DD[CR][LF]
// Response: DD,XXX,X,X,XXX.XX,XXXXXX,...[CR][LF]
void cmd_RDD_svc(void) {
    char resp[70];
    int  cnt = 0;
    int  resp_cnt = bd.cs610f.resp_cnt;
    
    if (++bd.cs610f.resp_cnt >= 1000)
        bd.cs610f.resp_cnt = 0;
    
    // ì‘ë‹µ í”„ë ˆì„ êµ¬ì„±
    resp[cnt++] = 'D';
    resp[cnt++] = 'D';
    resp[cnt++] = ',';
    
    cnt += sprintf(&resp[cnt], "%03d", resp_cnt);           // No
    resp[cnt++] = ',';
    cnt += sprintf(&resp[cnt], "%01d", bd.cs610f.meas_stat); // Status
    resp[cnt++] = ',';
    cnt += sprintf(&resp[cnt], "%01d", bd.cs610f.chem_type); // Chemical type
    resp[cnt++] = ',';
    cnt += sprintf(&resp[cnt], "%06.2f", bd.concent_str.temp_1);    // Temperature
    resp[cnt++] = ',';
    cnt += sprintf(&resp[cnt], "%06.2f", bd.concent_str.concent1);  // Concentration 1
    resp[cnt++] = ',';
    cnt += sprintf(&resp[cnt], "%06.2f", bd.concent_str.concent2);  // Concentration 2
    // ... ë‚˜ë¨¸ì§€ í•„ë“œ
    
    // ì‘ë‹µ ì „ì†¡
    term_printf(TPID_RS232, "%s\r\n", resp);
}
  ```
  ---


================================================================================
[í† ê¸€] ğŸ”§ ATIK JIG Board - ë³´ë“œ ì…ê³  í…ŒìŠ¤íŠ¸ ì¥ë¹„
================================================================================
  ğŸ› ï¸ ë³´ë“œ ì…ê³  í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•œ ìë™í™” í…ŒìŠ¤íŠ¸ ì¥ë¹„
  ### í”„ë¡œì íŠ¸ ê°œìš”
  - ì œí’ˆ: ìƒì‚°ë¼ì¸ ë³´ë“œ ì…ê³  í…ŒìŠ¤íŠ¸ìš© JIG
  - ì—­í• : íšŒë¡œ ì„¤ê³„ + íŒì›¨ì–´ ê°œë°œ (100%)
  - MCU: STM32F407 (ARM Cortex-M4)
  ### ì‹œìŠ¤í…œ ë¸”ë¡ ë‹¤ì´ì–´ê·¸ë¨
  ğŸ’¡ 
  ğŸ’¡ 
  ğŸ’¡ 
  ğŸ’¡ 
  ### í•µì‹¬ ê¸°ìˆ 
  - ë‹¤ì¤‘ UART ì¸í„°ëŸ½íŠ¸: 4ê°œ í¬íŠ¸ ë™ì‹œ í•¸ë“¤ë§
  - í ê¸°ë°˜ ë°ì´í„° ê´€ë¦¬: ë§ ë²„í¼ë¡œ ë°ì´í„° ì†ì‹¤ ë°©ì§€
  - ë‹¤ì¤‘ ì œí’ˆ ì§€ì›: L-Titrator, Nu-2000, Sigma, Psi ë“±
  - ìë™í™” í…ŒìŠ¤íŠ¸: ADC/DAC, í†µì‹ , GPIO ìë™ ê²€ì¦
  - ë¦´ë ˆì´/MUX ì œì–´: í…ŒìŠ¤íŠ¸ í¬ì¸íŠ¸ ìë™ ì„ íƒ
  ### ì½”ë“œ ìƒ˜í”Œ - ë©€í‹° UART ì¸í„°ëŸ½íŠ¸ ë° í
  ```c
// ATIK_JIG_main.c - UART ì¸í„°ëŸ½íŠ¸ ë° í ê¸°ë°˜ í†µì‹ 
// ë‹¤ì¤‘ UART í¬íŠ¸ ë™ì‹œ í•¸ë“¤ë§

/* ì§€ì› ì œí’ˆ ëª©ë¡ */
const char hw_model_str[16][30] = {
    "1.L-Titrator", "2.Nu-2000", "3.Sigma-3000/4000",
    "4.Psi-3000", "5.Psi-1000", "15.ATIK_JIG"
};

/* UART ìˆ˜ì‹  ì¸í„°ëŸ½íŠ¸ í•¸ë“¤ëŸ¬ - í ê¸°ë°˜ ë°ì´í„° ê´€ë¦¬ */
void my_uart_rx_irq_handler(UART_HandleTypeDef *huart) {
    TERM_PORT   tpid;
    UART_STR*   pUART;
    uint32_t    isrflags = READ_REG(huart->Instance->SR);
    
    // 1. UART í¬íŠ¸ ì‹ë³„ (ë©€í‹° í¬íŠ¸ ì§€ì›)
    if (huart->Instance == USART1)      { tpid = TPID_DEBUG; pUART = &uart[TPID_DEBUG]; }
    else if (huart->Instance == USART2) { tpid = TPID_PANEL; pUART = &uart[TPID_PANEL]; }
    else if (huart->Instance == USART3) { tpid = TPID_RS232; pUART = &uart[TPID_RS232]; }
    else if (huart->Instance == USART6) { tpid = TPID_RS485; pUART = &uart[TPID_RS485]; }
    else return;
    
    // 2. ë°ì´í„° ë° ì—ëŸ¬ ì½ê¸° (SR â†’ DR ìˆœì„œë¡œ ì—ëŸ¬ í”Œë˜ê·¸ í´ë¦¬ì–´)
    pUART->rx_err_flag = (isrflags & (USART_SR_PE | USART_SR_FE | USART_SR_ORE | USART_SR_NE));
    pUART->rx_data = (uint8_t)(huart->Instance->DR & 0x00FF);
    
    // 3. ìˆ˜ì‹  íì— ì €ì¥ (ë§ ë²„í¼)
    rxQ_write(tpid, pUART->rx_data);
    
    // 4. ì˜¤ë²„ëŸ° ë“± ì—ëŸ¬ ë¡œê¹…
    if (pUART->rx_err_flag)
        term_printf(TPID_DEBUG, "UART[%d] Err: 0x%08x\n", tpid, pUART->rx_err_flag);
}
  ```
  ---

## ğŸ› ï¸ ê¸°ìˆ  ìŠ¤íƒ
### í”„ë¡œê·¸ë˜ë° ì–¸ì–´
- C/C++ (Embedded), Python, Verilog
### MCU/í”„ë¡œì„¸ì„œ
- STM32 ì‹œë¦¬ì¦ˆ (F1, F4, G0, H7), Renesas RA6M4
### ê°œë°œ ë„êµ¬
- IDE: STM32CubeIDE, VS Code
- EDA: PADs, OrCAD
- ë²„ì „ ê´€ë¦¬: Git, Tortoise SVN
---
## ğŸ“ ì—°ë½ì²˜
- ğŸ“§ Email: 92lock@kakao.com
- ğŸ™ GitHub: github.com/Rakeen-Jo
ğŸ™ Thank you for reviewing my portfolio!